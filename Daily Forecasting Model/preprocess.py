import pandas as pd
import numpy as np

#Sort the registration data to fit only one student enrollment per ID
def sort_reg_data_setup(RSTS_DF):
    """
    Parameters:
        RSTS_DF (pd.DataFrame): Registration data pulled from Argos from ZREGUSR. 'ACTIVITYDATE' must be stored
                                in the CSV as 'MM/DD/YYYY hh:mm:ss'. It is crucial that the 'ss' be added. When it is 
                                downloaded from Argos, it must be downloaded by running the report, not from the 
                                'export to CSV' option. If the report is not downloaded correctly, the seconds will
                                not be downloaded in the ACTIVITYDATE and the filters will not work.

    Returns:
        pd.DataFrame: Returns the cleaned and sorted RSTS dataframe.
        
    """
    rsts = RSTS_DF

    #First make all column headers uppercase
    rsts.columns = [i.upper() for i in rsts.columns]

    #Alter RSTSDATE and ACTIVITYDATE to Datetime objects
    rsts['RSTSDATE'], rsts['ACTIVITYDATE'] = pd.to_datetime(rsts['RSTSDATE']), pd.to_datetime(rsts['ACTIVITYDATE'])

    #Make dictionary for RSTS column
    d = {'RE': 1, 'RW': 2, 'AU':3, 'DD': 4, 'DW': 5}

    #For loop to tie dictionary to RSTS for sorting
    RSTS_SORT = [d.get(i) for i in list(rsts['RSTS'])]

    #Integrate new column to 'registration' dataframe
    rsts['RSTS_SORT'] = RSTS_SORT

    #sort values so that first alteration to account is captured
    rsts = (rsts.sort_values(['ID', 'ACTIVITYDATE', 'RSTS_SORT'], ascending = True)
                .reset_index(drop = True)
                .groupby('ID').first() # Filter first instance of each ID
                .reset_index()
           )

    #filter first instance of each ID
    #rsts = rsts.groupby('ID').first().reset_index()

    #create columns for week number, day number, and month
    rsts['WEEK_NUM'], rsts['DAY_NUM'] = rsts['ACTIVITYDATE'].dt.isocalendar()['week'].astype(int),\
                                        rsts['ACTIVITYDATE'].dt.dayofyear
    
    rsts['MONTH'] = [i.strftime('%b') for i in rsts['ACTIVITYDATE']]

    #select only necessary columns
    rsts = rsts[['ID', 'TERM', 'MONTH', 'RESD', 'RSTS', 'RSTSDATE', 'ACTIVITYDATE',
                 'WEEK_NUM', 'DAY_NUM']]

    return rsts

def set_weeks(df, first_wk, final_wk, start_wk):
    """
    Parameters:
        df (pd.DataFrame): Dataframe of modified RSTS data pulled from Argos after it is ran through
                           sort_reg_data_setup().
        first_wk (str): String of date of first day of enrollment, denoted by the MONDAY date
                        in the format ('YYYY-MM-DD')
        final_wk (str): String of date of final week of enrollment in the format ('YYYY-MM-DD')
                        This date should be at the end of 12 weeks into the semester. Could even be
                        set after.
        start_wk (str): String of date of first week of class, denoted by the date of the first day of class.

    Returns:
        pd.DataFrame: Returns a dataframe in which the weeks of enrollment have been added to the 
                      RSTS dataframe.
                      
    """
    
    #first retrieve the start date of enrollment, end date of being able to drop,
    #and the start date of the semester
    first = pd.to_datetime(pd.Series([first_wk, pd.NaT]))
    final = pd.to_datetime(pd.Series([final_wk, pd.NaT]))
    start = pd.to_datetime(pd.Series([start_wk, pd.NaT]))

    #using the dates above, isolate the week number generated by .dt for the 
    #week number of the year for first_wk, final_wk, start_wk
    first_wk = first.dt.isocalendar()['week'][0].astype(int)

    final_wk = final.dt.isocalendar()['week'][0].astype(int)

    start_wk = start.dt.isocalendar()['week'][0].astype(int)

    #now we can use those numbers to create our range numbers
    end_of_range = (final_wk + (52-first_wk)) - (final_wk - start_wk) + 1

    start_of_range = -(final_wk - start_wk)

    #Finally we can combine those to create a dynamic week number dictionary
    wks = dict(zip(list(range(first_wk, (52 + 1), 1)) + list(range(1, (final_wk + 1), 1)), sorted(range(start_of_range, end_of_range, 1), reverse = True)))

    #apply wks dictionary to creating two new columns, the WEEK and the WEEK_NUM
    df['WEEK'], df['WEEK_NUM'] = ['WK ' + str(wks.get(i)) for i in df['WEEK_NUM']], \
                                 [wks.get(i) for i in df['WEEK_NUM']]

    df = df[['ID', 'TERM', 'MONTH', 'WEEK', 'WEEK_NUM', 'RESD', 'RSTS', 'RSTSDATE', 'ACTIVITYDATE', 'DAY_NUM']]
    
    return df

def set_days(df, first_day, final_day, start_day, last_day_of_yr):
    """
    Parameters:
        df (pd.DataFrame): Dataframe generated by the function set_weeks().
        first_day (str): First day of enrollment stored in the format 'YYYY-MM-DD'.
        final_day (str): Final day of enrollment in the format 'YYYY-MM-DD'. This date 
                         should be the same as the final_wk date in the set_weeks() function.
        start_day (str): First day of the semesteer stored in the format 'YYYY-MM-DD'.
        last_day_of_yr (str): This is literally the last day of the calendar year. 'YYYY-12-31'
                              The year is the only part that needs to be updated every semester.

    Returns:
        pd.DataFrame: Dataframe with the days of the enrollment period added. 
        
    """
    #set the first day of enrollment period, the last day students can 
    #drop, and the start day of classes
    first = pd.to_datetime(pd.Series([first_day, pd.NaT]))
    final = pd.to_datetime(pd.Series([final_day, pd.NaT]))
    start = pd.to_datetime(pd.Series([start_day, pd.NaT]))
    last_day_of_yr = pd.to_datetime(pd.Series([last_day_of_yr, pd.NaT]))

    #harvest the numerical day of the year on which each day falls
    first_day = first.dt.dayofyear[0].astype(int)
    final_day = final.dt.dayofyear[0].astype(int)
    start_day = start.dt.dayofyear[0].astype(int)
    EOY = last_day_of_yr.dt.dayofyear[0].astype(int)

    #create the start and end of the range used for the dictionary
    end_of_range = (final_day + (EOY-first_day)) - (final_day-start_day)
    start_of_range = -(final_day - start_day)

    #create a 'days' dictionary
    days = dict(zip(list(range(first_day, (EOY + 1), 1)) + list(range(1, (final_day + 1), 1)), sorted(range(start_of_range, (end_of_range + 1), 1), reverse = True)))

    df['DAY'] = [days.get(i) for i in df['DAY_NUM']]

    df = df[['ID', 'TERM', 'MONTH', 'WEEK', 'WEEK_NUM', 'DAY', 'RESD', 'RSTS', 'RSTSDATE', 'ACTIVITYDATE']]

    return df

def set_final(df, stud_df, majr_desc):
    """
    Parameters:
        df (pd.DataFrame): Dataframe generated by the set_days() function.
        stud_df (pd.DataFrame): Dataframe pulled from Argos's ZSTUDENT data. Downloaded and saved as 
                                csv file without modification.
        majr_desc (dict): Dictionary of four letter major codes as key and major description as the value.
                          This is updated each year as new majors come online. Old majors have to stay for 
                          five years.

    Returns: 
        pd.DataFrame: Returns dataframe with major descriptions added.
        
    """
    
    FINAL = df.merge(stud_df, how = 'left', on = 'ID').fillna("WD Before EOT")
    stype = ['C', 'T', 'G', 'H', 'N', 'A']

    present = []
    for i in list(FINAL['STYP']):
        if i in stype:
            present.append("SP25")
        else:
            present.append(i)

    FINAL['PRESENT'] = present
    
    majrs = []

    for i in FINAL['MAJR']:
        if i == '0':
            majrs.append('0000')
        else:
            majrs.append(i)

    FINAL['MAJR'] = majrs

    FINAL['MAJR_DESC'] = [majr_desc.get(i) for i in FINAL['MAJR']]
    
    FINAL['AGE'], FINAL['AGE_RANGE'] = "", ""
    
    FINAL = FINAL[['TERM', 'ID', 'PRESENT', 'WEEK', 'WEEK_NUM', 'MONTH', 'DAY', 'STYP', 'MAJR', 
                   'MAJR_DESC', 'AGE', 'AGE_RANGE', 'RESD', 'RSTS', 'RSTSDATE', 'ACTIVITYDATE']]
    
    return FINAL
